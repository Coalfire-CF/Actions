name: Readme Tree (Reusable on PR, external script)

on:
  workflow_call:
    inputs:
      commit_message:
        type: string
        default: "chore: update README tree structure"
      exclude_pattern:
        type: string
        default: ".git|node_modules|.github"
      working_directory:
        type: string
        default: "."
      script_repo:
        description: "owner/repo that contains the script"
        type: string
        required: true
      # script_ref intentionally removed – we auto-derive from the 'uses:' ref
      script_path:
        description: "path to script inside script_repo"
        type: string
        default: "scripts/update-readme-tree.sh"

permissions:
  contents: write
  pull-requests: write

jobs:
  update-readme-on-pr:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout PR head (downstream repo)
        uses: actions/checkout@v5
        with:
          ref: ${{ github.event.pull_request.head.ref || github.ref_name }}
          fetch-depth: 0

      - name: Configure git identity (early)
        run: |
          git config user.name "${{ github.actor }}"
          git config user.email "${{ github.actor }}@users.noreply.github.com"

      - name: Install tree
        run: |
          sudo apt-get install -y tree

      # --- Derive the ref used in `uses: owner/repo/.github/workflows/...@<ref>` ---
      - name: Derive script ref from caller
        id: derive
        shell: bash
        run: |
          set -euo pipefail
          echo "github.action_ref='${{ github.action_ref }}'"
          echo "github.workflow_ref='${{ github.workflow_ref }}'"
          echo "env.GITHUB_ACTION_REF='${GITHUB_ACTION_REF:-}'"

          # Prefer environment variable first (set by the runner for actions/reusables),
          # then GitHub context, then workflow_ref parsing.
          REF="${GITHUB_ACTION_REF:-}"
          if [ -z "$REF" ]; then
            REF="${{ github.action_ref }}"
          fi
          if [ -z "$REF" ]; then
            WF="${{ github.workflow_ref }}"     # e.g. org/repo/.github/...@refs/heads/branch
            REF="${WF#*@}"                      # take substring after '@'
          fi

          # If GitHub handed us a PR merge ref, do NOT use it for the script repo
          if [[ "$REF" == refs/pull/* ]]; then
            echo "Derived PR ref ($REF) — will use default branch of script repo."
            REF=""
          else
            echo "Using script ref: '${REF}'"
          fi

          echo "ref=$REF" >> "$GITHUB_OUTPUT"

      # Try to checkout the script repo at the SAME ref as the reusable workflow…
      - name: Checkout script repo (match reusable ref)
        id: checkout_match
        if: ${{ steps.derive.outputs.ref != '' }}
        uses: actions/checkout@v5
        continue-on-error: true
        with:
          repository: ${{ inputs.script_repo }}
          ref: ${{ steps.derive.outputs.ref }}
          path: _script_repo
          fetch-depth: 1

      # …otherwise (or if that ref doesn't exist there) fallback to script repo default branch
      - name: Checkout script repo (default branch fallback)
        if: ${{ steps.derive.outputs.ref == '' || steps.checkout_match.outcome == 'failure' }}
        uses: actions/checkout@v5
        with:
          repository: ${{ inputs.script_repo }}
          path: _script_repo
          fetch-depth: 1

      # Optional: show what we actually pulled
      - name: Show script checkout
        run: |
          git -C _script_repo rev-parse --abbrev-ref HEAD || true
          git -C _script_repo rev-parse --short=12 HEAD || true
          ls -la _script_repo || true
          ls -la _script_repo/scripts || true

      - name: Verify script exists
        run: |
          set -e
          SCRIPT="_script_repo/${{ inputs.script_path }}"
          test -f "$SCRIPT" || { echo "Missing script: $SCRIPT"; exit 1; }
          chmod +x "$SCRIPT"

      - name: Run updater
        id: run
        env:
          EXCLUDE_PATTERN: ${{ inputs.exclude_pattern }}
        run: |
          set +e
          "_script_repo/${{ inputs.script_path }}"
          code=$?
          echo "exit_code=$code" >> $GITHUB_OUTPUT
          exit 0

      # Ensure the script checkout never gets committed
      - name: Keep _script_repo out of the index
        run: |
          set -e
          echo "_script_repo" >> .git/info/exclude
          git restore --staged _script_repo 2>/dev/null || true
          rm -rf _script_repo || true

      # One-time self-heal if a stray submodule pointer landed previously
      - name: remove stray _script_repo gitlink if present
        id: heal
        run: |
          set -e
          changed=0
          # gitlink shows as mode 160000 in ls-files
          if git ls-files -s _script_repo 2>/dev/null | grep -q '^160000'; then
            echo "Removing stray _script_repo gitlink from index…"
            git rm -f --cached _script_repo || true
            if [ -f .gitmodules ]; then
              git config -f .gitmodules --remove-section submodule._script_repo 2>/dev/null || true
              if ! git config -f .gitmodules -l >/dev/null 2>&1; then
                rm -f .gitmodules
              fi
              git add .gitmodules || true
            fi
            if ! git diff --cached --quiet; then
              git commit -m "chore: remove stray _script_repo gitlink"
              changed=1
            fi
          else
            echo "No _script_repo gitlink present."
          fi
          echo "changed=$changed" >> "$GITHUB_OUTPUT"

      - name: Push self-heal commit (if any)
        if: ${{ steps.heal.outputs.changed == '1' }}
        run: git push origin HEAD

      - name: Commit & push if changed
        if: ${{ steps.run.outputs.exit_code == '10' }}
        run: |
          git add -A
          if git diff --cached --quiet; then
            echo "No changes to commit."
            exit 0
          fi
          git commit -m "${{ inputs.commit_message }}"
          git push origin HEAD
